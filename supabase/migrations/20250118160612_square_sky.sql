/*
  # Initialize Database Schema
  
  1. New Tables
    - `login_attempts`: Track failed login attempts
    - `security_events`: Track security-related events
    - `quiz_progress`: Track user quiz progress
    - `question_attempts`: Track individual question attempts
  
  2. Views
    - `user_mastery_stats`: Calculate user mastery statistics
    - `login_attempt_analysis`: Analyze login attempts for rate limiting
  
  3. Functions
    - `cleanup_old_attempts`: Remove old login attempts
    - `update_updated_at_column`: Update timestamps
    - `record_security_event`: Record security events
*/

-- First, let's drop any existing objects with CASCADE to handle dependencies
DROP VIEW IF EXISTS user_mastery_stats CASCADE;
DROP VIEW IF EXISTS question_mastery CASCADE;
DROP TABLE IF EXISTS question_attempts CASCADE;
DROP TABLE IF EXISTS login_attempts CASCADE;
DROP TABLE IF EXISTS security_events CASCADE;
DROP TABLE IF EXISTS quiz_progress CASCADE;
DROP FUNCTION IF EXISTS update_updated_at_column CASCADE;
DROP FUNCTION IF EXISTS cleanup_old_attempts CASCADE;

-- Create login_attempts table to track failed login attempts
CREATE TABLE login_attempts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  email TEXT NOT NULL,
  ip_address TEXT,
  attempted_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()),
  success BOOLEAN DEFAULT false
);

-- Create security_events table to track suspicious activities
CREATE TABLE security_events (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id),
  event_type TEXT NOT NULL,
  description TEXT,
  ip_address TEXT,
  user_agent TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);

-- Enable RLS on security tables
ALTER TABLE login_attempts ENABLE ROW LEVEL SECURITY;
ALTER TABLE security_events ENABLE ROW LEVEL SECURITY;

-- Create policies for security_events
CREATE POLICY "Users can view their own security events"
  ON security_events FOR SELECT
  USING (auth.uid() = user_id);

-- Function to cleanup old login attempts
CREATE OR REPLACE FUNCTION cleanup_old_attempts()
RETURNS void AS $$
BEGIN
  DELETE FROM login_attempts
  WHERE attempted_at < NOW() - INTERVAL '24 hours';
END;
$$ LANGUAGE plpgsql;

-- Create view for rate limiting analysis
CREATE OR REPLACE VIEW login_attempt_analysis AS
WITH recent_attempts AS (
  SELECT 
    email,
    COUNT(*) FILTER (WHERE NOT success) as failed_attempts,
    MAX(attempted_at) as last_attempt
  FROM login_attempts
  WHERE attempted_at > NOW() - INTERVAL '15 minutes'
  GROUP BY email
)
SELECT 
  email,
  failed_attempts,
  last_attempt,
  CASE 
    WHEN failed_attempts >= 5 THEN true 
    ELSE false 
  END as is_rate_limited
FROM recent_attempts;

-- Create the quiz_progress table
CREATE TABLE quiz_progress (
  user_id UUID PRIMARY KEY REFERENCES auth.users(id),
  questions_completed INTEGER DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);

-- Enable RLS
ALTER TABLE quiz_progress ENABLE ROW LEVEL SECURITY;

-- Create policies for quiz_progress
CREATE POLICY "Users can read their own progress"
  ON quiz_progress FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can update their own progress"
  ON quiz_progress FOR UPDATE
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can insert their own progress"
  ON quiz_progress FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Create the updated_at trigger function
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = timezone('utc'::text, now());
  RETURN NEW;
END;
$$ language 'plpgsql';

-- Create the trigger
CREATE TRIGGER update_quiz_progress_updated_at
  BEFORE UPDATE ON quiz_progress
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Create the question_attempts table
CREATE TABLE question_attempts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id),
  question_id INTEGER NOT NULL,
  correct BOOLEAN NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);

-- Enable RLS for question_attempts
ALTER TABLE question_attempts ENABLE ROW LEVEL SECURITY;

-- Create policies for question_attempts
CREATE POLICY "Users can read their own attempts" 
  ON question_attempts 
  FOR SELECT 
  TO authenticated
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own attempts" 
  ON question_attempts 
  FOR INSERT 
  TO authenticated
  WITH CHECK (auth.uid() = user_id);

-- Create the mastery stats view
CREATE OR REPLACE VIEW user_mastery_stats AS 
WITH mastered_questions AS (
  SELECT 
    question_id,
    user_id
  FROM (
    SELECT 
      question_id,
      user_id,
      COUNT(*) FILTER (WHERE correct) AS correct_count,
      COUNT(*) AS total_attempts
    FROM question_attempts
    GROUP BY question_id, user_id
    HAVING COUNT(*) >= 5 AND COUNT(*)
    FILTER (WHERE correct) >= 3
  ) AS question_stats
)
SELECT 
  user_id,
  COUNT(DISTINCT question_id) as mastered_questions,
  (SELECT COUNT(DISTINCT question_id) FROM question_attempts WHERE user_id = mq.user_id) as attempted_questions
FROM mastered_questions mq
GROUP BY user_id;

-- Grant access to the views
GRANT SELECT ON user_mastery_stats TO authenticated;
GRANT SELECT ON login_attempt_analysis TO authenticated;

-- Create function to record security events
CREATE OR REPLACE FUNCTION record_security_event(
  p_user_id UUID,
  p_event_type TEXT,
  p_description TEXT,
  p_ip_address TEXT DEFAULT NULL,
  p_user_agent TEXT DEFAULT NULL
) RETURNS void AS $$
BEGIN
  INSERT INTO security_events (
    user_id,
    event_type,
    description,
    ip_address,
    user_agent
  ) VALUES (
    p_user_id,
    p_event_type,
    p_description,
    p_ip_address,
    p_user_agent
  );
END;
$$ LANGUAGE plpgsql;