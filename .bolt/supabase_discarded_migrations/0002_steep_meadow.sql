/*
  # Initial Schema Setup
  
  1. New Tables
    - login_attempts: Track login attempts for rate limiting
    - security_events: Audit log for security-related events
    - quiz_progress: Track user quiz completion and scores
    - question_attempts: Record individual question attempts
    - user_preferences: Store user settings and consent
  
  2. Security
    - Enable RLS on all tables
    - Create policies for authenticated access
    - Add security functions for monitoring
*/

-- Drop existing objects if they exist
DO $$ BEGIN
  -- Drop triggers first
  DROP TRIGGER IF EXISTS update_quiz_progress_updated_at ON quiz_progress;
  DROP TRIGGER IF EXISTS update_user_preferences_updated_at ON user_preferences;
  
  -- Drop functions
  DROP FUNCTION IF EXISTS update_updated_at_column() CASCADE;
  DROP FUNCTION IF EXISTS cleanup_old_attempts() CASCADE;
  
  -- Drop tables if they don't have dependencies
  DROP TABLE IF EXISTS question_attempts CASCADE;
  DROP TABLE IF EXISTS quiz_progress CASCADE;
  DROP TABLE IF EXISTS user_preferences CASCADE;
  DROP TABLE IF EXISTS security_events CASCADE;
  DROP TABLE IF EXISTS login_attempts CASCADE;
EXCEPTION
  WHEN OTHERS THEN NULL;
END $$;

-- Create security tables
CREATE TABLE IF NOT EXISTS login_attempts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  email TEXT NOT NULL,
  ip_address TEXT,
  attempted_at TIMESTAMPTZ DEFAULT NOW(),
  success BOOLEAN DEFAULT false
);

CREATE TABLE IF NOT EXISTS security_events (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id),
  event_type TEXT NOT NULL,
  description TEXT,
  ip_address TEXT,
  user_agent TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create core application tables
CREATE TABLE IF NOT EXISTS quiz_progress (
  user_id UUID PRIMARY KEY REFERENCES auth.users(id),
  questions_completed INTEGER DEFAULT 0,
  total_attempts INTEGER DEFAULT 0,
  correct_answers INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS question_attempts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id),
  question_id INTEGER NOT NULL,
  correct BOOLEAN NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS user_preferences (
  id UUID PRIMARY KEY REFERENCES auth.users(id),
  marketing_consent BOOLEAN DEFAULT false,
  newsletter_consent BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Enable RLS on all tables
DO $$ BEGIN
  EXECUTE 'ALTER TABLE login_attempts ENABLE ROW LEVEL SECURITY';
  EXECUTE 'ALTER TABLE security_events ENABLE ROW LEVEL SECURITY';
  EXECUTE 'ALTER TABLE quiz_progress ENABLE ROW LEVEL SECURITY';
  EXECUTE 'ALTER TABLE question_attempts ENABLE ROW LEVEL SECURITY';
  EXECUTE 'ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY';
EXCEPTION
  WHEN OTHERS THEN NULL;
END $$;

-- Create policies for quiz_progress
DO $$ BEGIN
  DROP POLICY IF EXISTS "Users can read own progress" ON quiz_progress;
  CREATE POLICY "Users can read own progress"
    ON quiz_progress FOR SELECT
    TO authenticated
    USING (auth.uid() = user_id);

  DROP POLICY IF EXISTS "Users can update own progress" ON quiz_progress;
  CREATE POLICY "Users can update own progress"
    ON quiz_progress FOR UPDATE
    TO authenticated
    USING (auth.uid() = user_id)
    WITH CHECK (auth.uid() = user_id);

  DROP POLICY IF EXISTS "Users can insert own progress" ON quiz_progress;
  CREATE POLICY "Users can insert own progress"
    ON quiz_progress FOR INSERT
    TO authenticated
    WITH CHECK (auth.uid() = user_id);
END $$;

-- Create policies for question_attempts
DO $$ BEGIN
  DROP POLICY IF EXISTS "Users can read own attempts" ON question_attempts;
  CREATE POLICY "Users can read own attempts"
    ON question_attempts FOR SELECT
    TO authenticated
    USING (auth.uid() = user_id);

  DROP POLICY IF EXISTS "Users can insert own attempts" ON question_attempts;
  CREATE POLICY "Users can insert own attempts"
    ON question_attempts FOR INSERT
    TO authenticated
    WITH CHECK (auth.uid() = user_id);
END $$;

-- Create policies for user_preferences
DO $$ BEGIN
  DROP POLICY IF EXISTS "Users can read own preferences" ON user_preferences;
  CREATE POLICY "Users can read own preferences"
    ON user_preferences FOR SELECT
    TO authenticated
    USING (auth.uid() = id);

  DROP POLICY IF EXISTS "Users can update own preferences" ON user_preferences;
  CREATE POLICY "Users can update own preferences"
    ON user_preferences FOR UPDATE
    TO authenticated
    USING (auth.uid() = id)
    WITH CHECK (auth.uid() = id);

  DROP POLICY IF EXISTS "Users can insert own preferences" ON user_preferences;
  CREATE POLICY "Users can insert own preferences"
    ON user_preferences FOR INSERT
    TO authenticated
    WITH CHECK (auth.uid() = id);
END $$;

-- Create policies for security_events
DO $$ BEGIN
  DROP POLICY IF EXISTS "Users can view their own security events" ON security_events;
  CREATE POLICY "Users can view their own security events"
    ON security_events FOR SELECT
    TO authenticated
    USING (auth.uid() = user_id);
END $$;

-- Create updated_at trigger function
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ language 'plpgsql';

-- Create triggers for updated_at
DROP TRIGGER IF EXISTS update_quiz_progress_updated_at ON quiz_progress;
CREATE TRIGGER update_quiz_progress_updated_at
  BEFORE UPDATE ON quiz_progress
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_user_preferences_updated_at ON user_preferences;
CREATE TRIGGER update_user_preferences_updated_at
  BEFORE UPDATE ON user_preferences
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Create function to cleanup old login attempts
CREATE OR REPLACE FUNCTION cleanup_old_attempts()
RETURNS void AS $$
BEGIN
  DELETE FROM login_attempts
  WHERE attempted_at < NOW() - INTERVAL '24 hours';
END;
$$ LANGUAGE plpgsql;